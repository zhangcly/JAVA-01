学习笔记

## GC的判定算法
* 引用计数法：对象的引用次数进行计数，当没有别的对象使用这个对象时进行gc。存在问题：循环引用。
* 可达性分析：判断从gcroots到某个对象是否可达，解决了循环引用导致内存泄漏的问题。

## GC算法
* 标记清除：如何清理上百万的对象？STW。
* 标记清除整理/压缩算法
* 标记复制算法

**分代假设**：大部分新生对象很快无用，存活较长的对象可能存活的时间更长。基于分代假设，jvm将堆内存分为新生代和老年代。新生代采用标记复制算法，老年代采用标记清除整理算法。

可以作为GC roots的对象：
1.正在执行的方法中的局部变量和输入参数
2.活动线程
3.所有类的静态字段
4.JNI引用

## GC策略
### 串行GC（Serial GC）/ParNewGc
串行gc对年轻代使用标记复制算法，对老年代使用标记清除整理算法。都是单线程的，不能并行处理，触发STW。不能充分利用多核CPU性能，只有一个核心在进行垃圾收集。适合只有几百MB堆内存的JVM，而且是单核CPU比较使用，
### 并行GC （Parallel GC）
* -XX: +UseParrelGc
* -XX: +UseParrelOldGc
* -XX: +UseParrelGc -XX: +UseParrelOldGc

年轻代和老年代都会触发STW。年轻代使用标记复制算法，老年代使用标记清除整理算法，使用-XX ParallelGcThreads=N来制定GC线程数，默认值为CPU核心数。并行GC适用于多核服务器，吞吐量最高。在GC期间所有CPU核心都在并行清理垃圾，总暂停时间比串行GC时间更短；两次GC期间的间隔期，没有GC线程运行，不会消耗任何系统资源。java8中默认的GC就是并行GC。

### CMS GC（Mostly COncurrent Mark and Sweep Garbage Collector）
 * -XX：+UseConcMarkSweepGc
 
 年轻代使用标记复制，老年代使用并发标记清除散发。CMS设计目标是避免老年代垃圾手机出现长时间的卡顿，主要通过两种手段：
 * 不对老年代进行整理，而是用空闲列表来管理内存空间的回收
 * 标记清除阶段的大部分工作和应用线程一起并发执行，默认情况下GC使用的线程为CPU核心数的1/4
 
 CMS的六个阶段：
* 初始化标记（Initial Mark）。这个阶段会STW，标记所有根对象和根对象的直接引用，以及被年轻代中所有存活对象引用的对象。
* 并发标记（Concurrent Mark）。便利老年代，标记老年代所有存活对象。
* 并发预清理（Concurrent Preclean）。有对象变了就将之前标记的对象标记为脏对象。
* 最终标记（Final Remark）。第二次STW，对脏对象再次进行标记。
* 并发清除（Concurrent Sweep）
* 并发重置（Concurrent Reset）回收内存空间，GC中用到的各种计数器清零。

### G1 GC（Garbage First）
* -XX：+UseG1GC -XX：MaxGCPauseMillis=50

G1的设计目标是将STW停顿的时间和分布变得可预期且可配置。G1中，堆不在分为年轻代和老年代，而是划分为多个（通常为2048个）可以存放对象的小块堆区域（smaller heap regions）。每个小块，可能一会被定义成Eden区，一会被指定为Survivor区或者Old区。逻辑上，所有Eden和Survivor区为年轻代，所有old区为老年代。这样G1就可以以增量进行处理，每次处理一小部分，每次GC都会收集所有年轻代的内存块，但老年代一般只会回收一部分。G1在并发阶段会估算每个小堆快的存活对象数，垃圾最多的小块会优先回收。

G1的处理步骤：
* 年轻代模式转移暂停（Evacuation Pause）。G1对通过前面一段时间的运行时间来不断调整自己的回收策略和行为，当G1还没有采集到的足够的信息的时候，出于初始的fully young模式，当年轻代空间用满后，应用线程被暂停，年轻代对象中的存活对象被拷贝至存货去，如果还没有存活区就先选择任意一部分空闲内存作为存活区。
* 并发标记（Concurrent Marking）。与CMS GC类似，但G1中有两种情况是可以完全并发执行的：1.标记阶段时某个小堆被确定没有存活对象只包含垃圾；2.在STW转移暂停期间同时包含垃圾和存活对象的小堆块。
 > 阶段 1: Initial Mark（初始标记） 此阶段标记所有从 GC 根对象直接可达的对象。

 > 阶段 2: Root Region Scan（Root区扫描） 此阶段标记所有从 "根区域" 可达的存活对象。根区域包括：非空的区域，以及在标记过程中不得不收集的区域。 

 > 阶段 3: Concurrent Mark（并发标记） 此阶段和 CMS 的并发标记阶段非常类似：只遍历对象图，并在一个特殊的位图中标记能访问到的对象。 

 > 阶段 4: Remark（再次标记） 和 CMS 类似，这是一次 STW 停顿(因为不是并发的阶段)，以完成标记过程。 G1 收集器会短暂地停止应用线 程，停止并发更新信息的写入，处理其中的少量信息，并标记所有在并发标记开始时未被标记的存活对象。 

 > 阶段 5: Cleanup（清理） 最后这个清理阶段为即将到来的转移阶段做准备，统计小堆块中所有存活的对象，并将小堆块进行排序，以提升 GC 的效率，维护并发标记的内部状态。 所有不包含存活对象的小堆块在此阶段都被回收了。有一部分任务是并 发的：例如空堆区的回收，还有大部分的存活率计算。此阶段也需要一个短暂的 STW 暂停。

* 转移暂停: 混合模式（Evacuation Pause (mixed)）。并发标记完成之后，G1将执行一次混合收集（mixed collection），就是不只清理年轻代，还将一部 分老年代区域也加入到 回收集 中。混合模式的转移暂停不一定紧跟并发标记阶段。有很多规则和历 史数据会影响混合模式的启动时机。比如，假若在老年代中可以并发地腾出很多的小堆块，就没有必 要启动混合模式

### ZGC和Shenandoah GC
* -XX:+UnlockExperimentalVMOptions -XX:+UseZGC -Xmx16g

ZGC 最主要的特点包括: 1. GC 最大停顿时间不超过 10ms 2. 堆内存支持范围广，小至几百 MB 的堆空间，大至 4TB 的超大堆 内存（JDK13 升至 16TB） 3. 与 G1 相比，应用吞吐量下降不超过 15% 4. 当前只支持 Linux/x64 位平台，JDK15 后支持 MacOS 和 Windows 系统

* -XX:+UnlockExperimentalVMOptions - XX:+UseShenandoahGC -Xmx16g 

Shenandoah GC 立项比 ZGC 更早，设计 为GC 线程与应用线程并发执行的方式，通 过实现垃圾回收过程的并发处理，改善停顿 时间，使得 GC 执行线程能够在业务处理线 程运行过程中进行堆压缩、标记和整理，从 而消除了绝大部分的暂停时间。 Shenandoah 团队对外宣称 Shenandoah GC 的暂停时间与堆大小无关，无论是 200 MB 还是 200 GB的堆内存，都可以保障具 有很低的暂停时间（注意:并不像 ZGC 那样 保证暂停时间在 10ms 以内）。

## 总结
1. 串行 GC（Serial GC）: 单线程执行，应用需要暂停； 
2. 并行 GC（ParNew、Parallel Scavenge、Parallel Old）: 多线程并行地执行垃圾回收， 关注与高吞吐； 
3. CMS（Concurrent Mark-Sweep）: 多线程并发标记和清除，关注与降低延迟； 
4. G1（G First）: 通过划分多个内存区域做增量整理和回收，进一步降低延迟； 
5. ZGC（Z Garbage Collector）: 通过着色指针和读屏障，实现几乎全部的并发执行，几 毫秒级别的延迟，线性可扩展； 
6. Epsilon: 实验性的 GC，供性能分析使用； 
7. Shenandoah: G1 的改进版本，跟 ZGC 类似。

GC算法的实现和演进路线：
1. 串行 -> 并行: 重复利用多核 CPU 的优势，大幅降低 GC 暂停时间，提升吞吐量。 
2. 并行 -> 并发： 不只开多个 GC 线程并行回收，还将GC操作拆分为多个步骤，让很多繁重的任务和应用线程一 起并发执行，减少了单次 GC 暂停持续的时间，这能有效降低业务系统的延迟。 
3. CMS -> G1： G1 可以说是在 CMS 基础上进行迭代和优化开发出来的，划分为多个小堆块进行增量回收，这样 就更进一步地降低了单次 GC 暂停的时间 
4. G1 -> ZGC:：ZGC 号称无停顿垃圾收集器，这又是一次极大的改进。ZGC 和 G1 有一些相似的地方，但是底层 的算法和思想又有了全新的突破。